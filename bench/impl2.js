import {
  DEFINITION_LOOKUP_TABLE,
  LOOKUP_DEFINITIONS_INDEX,
  LOOKUP_DIR_INDEX,
  SEQUENCE_HASH_LENGTH,
  SEQUENCE_PREFIX,
} from "@fluentui/make-styles";
import hash from "@emotion/hash";

const B = 'ssssss'

function padEndHash(value) {
  const hashLength = value.length;

  if (hashLength === SEQUENCE_HASH_LENGTH) {
    return value;
  }

  for (let i = hashLength; i < SEQUENCE_HASH_LENGTH; i++) {
    value += "0";
  }

  return value;
}

export function hashSequence(classes, dir) {
  return SEQUENCE_PREFIX + padEndHash(hash(classes + dir));
}

function reduceToClassName(classMap, dir) {
  let className = "";

  // eslint-disable-next-line guard-for-in
  for (const propertyHash in classMap) {
    const classNameMapping = classMap[propertyHash];

    if (classNameMapping) {
      const hasRTLClassName = Array.isArray(classNameMapping);

      if (dir === "rtl") {
        className +=
          (hasRTLClassName ? classNameMapping[1] : classNameMapping) + " ";
      } else {
        className +=
          (hasRTLClassName ? classNameMapping[0] : classNameMapping) + " ";
      }
    }
  }

  return className.slice(0, -1);
}

// Contains a mapping of previously resolved sequences of atomic classnames
const mergeClassesCachedResults = {};

const SEQUENCE_SIZE = SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH;

export function mergeClasses() {
  // arguments are parsed manually to avoid double loops as TS & Babel transforms rest via an additional loop
  // @see https://babeljs.io/docs/en/babel-plugin-transform-parameters

  let dir = null;
  let resultClassName = "";
  // Is used as a cache key to avoid object merging
  let sequenceMatch = "";
  // const sequenceIds = [];

  for (let i = 0; i < arguments.length; i++) {
    // eslint-disable-next-line prefer-rest-params
    const className = arguments[i];

    if (typeof className === "string") {
      // All classes generated by `makeStyles()` are prefixed by a sequence hash, this allows to identify class sets
      // without parsing each className in a string
      const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);

      if (sequenceIndex === -1) {
        resultClassName += className + " ";
      } else {
        const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);

        // sequenceIds.push(sequenceId);
        sequenceMatch += B + sequenceId;

        // Handles a case with mixed classnames, i.e. "ui-button ATOMIC_CLASSES"
        if (sequenceIndex > 0) {
          resultClassName += className.slice(0, sequenceIndex);
        }
      }

      if (process.env.NODE_ENV !== "production") {
        if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {
          // eslint-disable-next-line no-console
          console.error(
            "mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start " +
              `with "${SEQUENCE_PREFIX}"), it's possible that passed classes were concatenated in a wrong way. ` +
              `Source string: ${className}`
          );
        }
      }
    }
  }

  // .slice() there allows to avoid trailing space for non-atomic classes
  // "ui-button ui-flex " => "ui-button ui-flex"
  if (sequenceMatch === "") {
    return resultClassName.slice(0, -1);
  }

  // It's safe to reuse results to avoid continuous merging as results are stable
  // "__seq1 ... __seq2 ..." => "__seq12 ..."
  const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];

  if (mergeClassesResult !== undefined) {
    return resultClassName + mergeClassesResult;
  }

  const sequenceMappings = [];

  sequenceMatch.split(B).forEach((sequenceId) => {
    const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];

    if (sequenceMapping) {
      sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);

      if (process.env.NODE_ENV !== "production") {
        if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) {
          // eslint-disable-next-line no-console
          // console.error(
          //   `mergeClasses(): a passed string contains an identifier (${sequenceId}) that has different direction ` +
          //     `(dir="${
          //       sequenceMapping[1] ? "rtl" : "ltr"
          //     }") setting than other classes. This is not supported. ` +
          //     `Source string: ${className}`
          // );
        }
      }

      dir = sequenceMapping[LOOKUP_DIR_INDEX];
    } else {
      if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        // console.error(
        //   `mergeClasses(): a passed string contains an identifier (${sequenceId}) that does not match any entry ` +
        //     `in cache. Source string: ${className}`
        // );
      }
    }
  });

  // eslint-disable-next-line prefer-spread
  const resultDefinitions = Object.assign.apply(
    Object,
    // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
    [{}].concat(sequenceMappings)
  );

  let atomicClassNames = reduceToClassName(resultDefinitions, dir);

  // Each merge of classes generates a new sequence of atomic classes that needs to be registered
  const newSequenceHash = hashSequence(atomicClassNames, dir);
  atomicClassNames = newSequenceHash + " " + atomicClassNames;

  mergeClassesCachedResults[sequenceMatch] = atomicClassNames;
  DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultDefinitions, dir];

  return resultClassName + atomicClassNames;
}
